import pyaudio
import wave
import array as arr
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np
import scipy as sp
from scipy.signal import find_peaks

# WIFI/SOCKET START
import socket # to connect to C++ robot code 
import struct
import time

ip = '' # Bind to all network interfaces
port = 3333
max_buffer_size  = 1024

fs = 44100 # samples per second
FORMAT = pyaudio.paInt16 # 16 bits per sample
#Audio Channels
CHANNELS = 1 #1 microphone
#CHANNELS = 2 # 2 microphones
chunk = 1024 # record in chunks of 1024 samples
filename = "output.wav"

#def callback(in_data, frame_count, time_info, status):
 #   data = np.frombuffer(in_data, dtype=np.Int16)
  #  print(data)

#SOCKET CONNECTION
HOST = 'localhost' #IP address of C++ program
PORT = 12345 #port # to use
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind((HOST, PORT))
sock.listen(1)
conn, addr = sock.accept()
theta_arr = arr. array('d', [0] * 100) # LIST array to store all values of theta so we can go back and pick theta corresponding the max amp
theta_list =[[0],[0]] #[time],[theta]: list to store all values of theta sent over AND the time that they occurred at
i = 0 #initialize incrementing variable
#START GETTING VALUES OF THETA
if __name__ == '__main__':
    UDPServerSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
    UDPServerSocket.bind((ip, port))
    theta = 1 #set theta != 0 so we can enter while loop
    while theta != 0: #Read theta values until they =0, meaning we having finished 360 degrees 
        #NEED TO GET THETA TO WRAP BACK TO 0 IN C++
        #RECEIVE PACKET 
        (theta_by, ip_address) = UDPServerSocket.recvfrom(max_buffer_size) #WILL THETA BE IN BYTES, RIGHT? 
        theta_str = theta_by.decode('utf-8') #decode bytes to a string
        theta_split = theta_str.split() #split string into words by space (gets indiidual values)
        time_str = theta_split[1] #store ONLY time values
        theta_str = theta_split[0] #store ONLY theta value in theta_str WILL IT BE MORE THAN LENGTH 2??
        
        theta = float(theta_str) # convert string to float number
        t = float(time_str) #convert string to float
       
        #how do I continuously update this?
        #REMEMBER: theta_list[i][0] = 0, extended after this first value of 0
        theta_list[0].extend([t]) #extend with new time 
        theta_list[1].extend([theta]) #extend with new theta
        #array instead of list:
        #theta_arr[i] = theta #store theta in array 2*n array for time
        
        #i=i+1 #increment i WHERE CAN I DO THIS?
        print('Message received: {}'.theta_str) #prints theta as string
        
        #START RECORDING, WHEN WE START GETTING VALUES OF THETA 
        #2 MICS
        #Device info for each mic
        # audio = pyaudio.PyAudio()
        # device_indexes = [0,1] #2 mics, [0,1,2] #3 mics
        # devices = [audio.get_device_info_by_host_api_device_index(i) for i in device_indexes]

        #open audio streams for each mic

        #1
        audio = pyaudio.PyAudio() 
        stream = audio.open(format=FORMAT,
                            channels=CHANNELS,
                            rate=fs,
                            input=True,
                            frames_per_buffer=chunk)

        frames = [] # stores recorded data
        # Store data in chunks for 3 seconds
        for i in range(0, int(fs/ chunk * 5)):
            data = stream.read(chunk)
            frames.append(data)

        # Stop and close the stream
        stream.stop_stream()
        stream.close()
        audio.terminate()

        #Create Max Theta Array
        maxtheta = arr.array('d', [0] * 2) #only need two elements, initial 0 and final max
        maxtheta[0] = 0 

        #FIND THE PEAK VOLUME/AMP TO FIND MAXTHETA
        #2+ mics

        #1 MIC
        #theta = 0; 
        # Open and plot output.wave
        wf = wave.open(filename, 'wb')
        wf.setnchannels(CHANNELS)
        wf.setsampwidth(audio.get_sample_size(FORMAT))
        wf.setframerate(fs)
        wf.writeframes(b''.join(frames))
        wf.close()

        spf = wave.open("output.wav", "r")
        sig1 = spf.readframes(-1)
        sig1 = np.frombuffer(sig1, dtype=np.int16)
        fs = spf.getframerate()
        Time = np.linspace(0, len(sig1) / fs, num=len(sig1))

        plt.figure(1)
        plt.title("Signal Wave")
        plt.plot(Time, sig1)
        #plt.show()
        # Start animation
        peaks, _ = find_peaks(sig1,prominence=1) #try without prominence
        maxpeak = peaks[np.argmax(sig1[peaks])]
        xmax = Time[maxpeak] #time that max occurs
        maxtheta[1] = theta_arr[xmax] #set maxtheta to the theta in theta_arr that occurs at time xmax
        print('Max peak occurs at time= ', xmax)
        plt.figure(2)
        plt.title("Max Peak")
        plt.plot(Time,sig1) #INTERPOLATION
        plt.plot(Time[peaks],sig1[peaks], 'x'); #plt.plot(signal); plt.legend(['prominence'])
        #plt.axvline(Time=xmax, ls='--', color="k")
        plt.show()
    #once theta=0, exit loop -> spin is over2

 # SEND PACKET AFTER EXITING WHILE LOOP (SPIN IS OVER)
    x = [1.234, 5.678]
    print('Sending {}'.format(x))
    x = struct.pack("f", x[0]) #Send back theta
    UDPServerSocket.sendto(x, ip_address)



#The position of mouse at xmax is where we want it to rotate to for the starting position

#INITIAL 360 SPIN
#left wheel fwd, right wheel bkwd at constant speed
#constantly update theta position
#at each peak found, update thetamax
#if(peak) thetamax = theta *FIRST TIME
#maxpeak = peak *FIRST TIME
#when max peak is found, save thetamax
#if(peak>maxpeak) maxpeak = peak; thetamax = theta
#when 360 is finished, return to thetamax
#move on to other code (CROSS CORRELATION)

#begin recording of all 3 microphones
#store 3 signals as 3 different functions
#use cross correlation to compare functions, find time delay
#use time delay to triangulate/find angles
